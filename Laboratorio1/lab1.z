Z => Z chs := fn(Z n) -> sub(n)(0);
Z => Z => Z add := fn(Z n) -> fn(Z k) -> sub(chs(n))(k); 

Z => Z => Z ne   := 1 si ambos argumentos son distintos, 0 de otra forma.
Z => Z => Z ne := fn(Z x) -> fn(Z y) -> if(lt(y)(x), 1, lt(x)(y));

Z => Z => Z xor  := 0 si ambos argumentos valuan a true o a false, 1 de otra forma.
Z => Z => Z xor := fn(Z x) -> fn(Z y) -> if(x, if(y, 0, 1), if(y, 1, 0));

Z => Z      sgn  := retorna 1 si el numero es positivo, 0 si es 0, y -1 si es negativo.
Z => Z sgn := fn(Z x) -> if(lt(x)(0), 1, if(lt(0)(x), sub(1)(0), 0));

Z => Z      abs  := retorna el valor absolute de un numero.
Z => Z abs := fn(Z x) -> if(lt(0)(x), chs(x), x);

Z => Z => Z mulP := retorna la multiplicacion de dos numeros positivos.
Z => Z => Z mulP := fn(Z x) -> fn(Z y) -> if(y, add(x)(mulP(x)(sub(1)(y))), 0);

Z => Z => Z mul  := retorna la multiplicacion de dos numeros cualquiera.
Z => Z => Z mul := fn(Z x) -> fn(Z y) -> if( xor(lt(x)(0))(lt(y)(0)), chs(mulP(abs(x))(abs(y))), mulP(abs(x))(abs(y)));

Z => Z      sqrt := retorna el piso de la raiz cuadrada de un numero positivo.
Z => Z => Z sqrt_aux := fn(Z n) -> fn(Z i) -> if(lt(mulP(add(1)(i))(add(1)(i)))(n), i, sqrt_aux(n)(add(1)(i)));
Z => Z sqrt := fn(Z n) -> sqrt_aux(n)(0);

Codigo directo para ejecutar en Intialc 
Z => Z chs := fn(Z n) -> sub(n)(0);
Z => Z => Z add := fn(Z n) -> fn(Z k) -> sub(chs(n))(k);
Z => Z => Z ne := fn(Z x) -> fn(Z y) -> if(lt(y)(x), 1, lt(x)(y));
Z => Z => Z xor := fn(Z x) -> fn(Z y) -> if(x, if(y, 0, 1), if(y, 1, 0));
Z => Z sgn := fn(Z x) -> if(lt(x)(0), 1, if(lt(0)(x), sub(1)(0), 0));
Z => Z abs := fn(Z x) -> if(lt(0)(x), chs(x), x);
Z => Z => Z mulP := fn(Z x) -> fn(Z y) -> if(y, add(x)(mulP(x)(sub(1)(y))), 0);
Z => Z => Z mul := fn(Z x) -> fn(Z y) -> if( xor(lt(x)(0))(lt(y)(0)), chs(mulP(abs(x))(abs(y))), mulP(abs(x))(abs(y)));
Z => Z => Z sqrt_aux := fn(Z n) -> fn(Z i) -> if(lt(mulP(add(1)(i))(add(1)(i)))(n), i, sqrt_aux(n)(add(1)(i)));
Z => Z sqrt := fn(Z n) -> sqrt_aux(n)(0); 
